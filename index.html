<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Textured Room – Step 2 (OrbitControls)</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #111; }
    canvas { display: block; }
    .hint {
      position: absolute; top: 10px; left: 50%;
      transform: translateX(-50%);
      color: #ddd; background: rgba(0,0,0,0.35);
      padding: 6px 10px; border-radius: 8px;
      font-family: sans-serif; font-size: 14px;
    }
  </style>
</head>
<body>
<div class="hint">Drag = rotate · Scroll = zoom · Right-drag = pan · R = reset</div>

<!-- Library Three.js & OrbitControls via CDN -->
<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>

<script>
    
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x222222);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
  const defaultPos = new THREE.Vector3(0, 1.5, 3);
  camera.position.copy(defaultPos);
  camera.lookAt(0, 1, 0);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // OrbitControls
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.target.set(0, 1,0);
  controls.minDistance = 1;
  controls.maxDistance = 8;

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();
// ====== Cahaya ======
const ambient = new THREE.AmbientLight(0xffffff, 0.4);
const point = new THREE.PointLight(0xffffff, 1.0, 100);
point.position.set(0, 2.4, 0);
scene.add(ambient, point);

// ====== Loader Tekstur ======
const loader = new THREE.TextureLoader();

function makeFallback(label) {
  const c = document.createElement('canvas'); c.width = c.height = 256;
  const ctx = c.getContext('2d');
  ctx.fillStyle = '#2a2a2a'; ctx.fillRect(0,0,256,256);
  ctx.fillStyle = '#999'; ctx.font = '16px system-ui'; ctx.fillText(label, 20, 130);
  return new THREE.CanvasTexture(c);
}

function safeLoad(path, label) {
  let tex = loader.load(
    path,
    () => { tex.needsUpdate = true; },
    undefined,
    () => { tex = makeFallback(label); }
  );
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.minFilter = THREE.LinearMipmapLinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
  return tex;
}

const floorTex   = safeLoad('floor.jpg',   'floor.jpg?');
const wallTex    = safeLoad('wall.jpg',    'wall.jpg?');
const ceilingTex = safeLoad('ceiling.jpg', 'ceiling.jpg?');

// ====== Material ======
const matFloor   = new THREE.MeshStandardMaterial({ map: floorTex, side: THREE.FrontSide });
const matWall    = new THREE.MeshStandardMaterial({ map: wallTex,  side: THREE.DoubleSide });
const matCeiling = new THREE.MeshStandardMaterial({ map: ceilingTex, side: THREE.FrontSide });

// ====== Geometri Ruangan ======
const W = 4, H = 3, D = 6;

// Lantai
const floor = new THREE.Mesh(new THREE.PlaneGeometry(W, D), matFloor);
floor.rotation.x = -Math.PI / 2;
floor.position.set(0, 0, 0);
scene.add(floor);

// Atap
const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(W, D), matCeiling);
ceiling.rotation.x = Math.PI / 2;
ceiling.position.set(0, H, 0);
scene.add(ceiling);

// Dinding belakang
const backWall = new THREE.Mesh(new THREE.PlaneGeometry(W, H), matWall);
backWall.position.set(0, H/2, -D/2);
scene.add(backWall);

// Dinding depan
const frontWall = new THREE.Mesh(new THREE.PlaneGeometry(W, H), matWall);
frontWall.rotation.y = Math.PI;
frontWall.position.set(0, H/2, D/2);
scene.add(frontWall);

// Dinding kiri
const leftWall = new THREE.Mesh(new THREE.PlaneGeometry(D, H), matWall);
leftWall.rotation.y = -Math.PI / 2;
leftWall.position.set(-W/2, H/2, 0);
scene.add(leftWall);

// Dinding kanan
const rightWall = new THREE.Mesh(new THREE.PlaneGeometry(D, H), matWall);
rightWall.rotation.y = Math.PI / 2;
rightWall.position.set(W/2, H/2, 0);
scene.add(rightWall);

  // Responsif
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Reset kamera (R)
  window.addEventListener('keydown', (e) => {
    if (e.key === 'r' || e.key === 'R') {
      camera.position.copy(defaultPos);
      controls.target.set(0, 1, 0);
      controls.update();
    }
  });
</script>
</body>
</html>
